names(notebook$cells)
ReactiveNotebook <- R6Class("ReactiveNotebook",
public = list(
cells = list(),
initialize = function() {
private$env <- new.env()
},
run_in_env = function(code) {
eval(parse(text = code), private$env)
},
move = function(source, destination) {
self$cells <- map(self$cells, function(cell) {
if(cell$position == source) cell$position <- destination
cell
})
o <- rank(unlist(lapply(self$cells, '[', 'position')))
print(o)
i <- 1
for(id in names(self$cells)) {
self$cells[[id]]$position <- o[i]
i <- i + 1
}
o
},
delete_cell = function(cell) {
if(is.null(self$cells[[cell$id]])) return()
if(!is.null(self$cells[[cell$id]]$name)) {
self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, ")"))
self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, "_saved)"))
}
position <- self$cells[[cell$id]]$position
self$cells[[cell$id]] <- NULL
self$cells <- map(self$cells, function(cell) {
if(cell$position > position) cell$position <- cell$position - 1
cell
})
if(cell$id %in% names(V(private$graph))) {
private$graph <- delete.vertices(private$graph, V(private$graph)[[cell$id]])
}
},
run_cell = function(cell, update = TRUE) {
private$callstack = c()
# Capture plots
while(dev.cur() > 1) dev.off()
ggplot2:::.store$set(NULL)
svgPath <- paste0(file.path(staticDir, cell$id), ".svg")
svg(filename = svgPath)
dev.control(displaylist = "enable")
#eval(parse(text = paste0("svg('", str_replace_all(svgPath, "\\\\", "/"), "')")), private$env)
#eval(parse(text = 'dev.control(displaylist = "enable")'), private$env)
name <- NULL
if(str_detect(cell$value, "^.+ <-")) {
name <- str_match(cell$value, "^(.+?) ?<-")[,2]
modified_cell <- str_replace(cell$value, paste0("^", name), paste0(name, "_saved"))
self$run_in_env(private$wrap(name))
res <- self$run_in_env(modified_cell)
}
else {
res <- eval(parse(text = cell$value), private$env)
}
#p <- eval(parse(text = "recordPlot()"), private$env)
p <- recordPlot()
p2 <- last_plot()
dev.off()
if(!is.null(p2)) {
ggsave(svgPath)
}
hasImage = !is.null(p[[1]]) || !is.null(p2)
pos <- cell$position
if(is.null(pos) && length(self$cells) > 0) {
positions <- sapply(self$cells, `[[`, "position")
pos <- max(positions) + 1
}
else if(is.null(pos)){
pos <- 1
}
self$cells <- map(self$cells, function(cell) {
if(cell$position >= pos) cell$position <- cell$position + 1
cell
})
self$cells[[cell$id]] = list(
id = cell$id,
value = cell$value,
position = pos,
hasImage = hasImage,
name = name,
result = res
);
if(!is.null(name)) {
private$name_to_id[name] = cell$id
}
if(!(cell$id %in% names(V(private$graph)))) {
private$graph <- add_vertices(private$graph, 1, name = cell$id)
}
for(call in private$callstack) {
call_id <- private$name_to_id[call]
if(!are.connected(private$graph, cell$id, call_id)) {
private$graph <- add_edges(private$graph, c(cell$id, call_id))
}
}
if(is.null(res)) res <- ""
updates = c(cell$id)
if(update == TRUE) {
# Get dependencies
ego_graph <- make_ego_graph(self$getGraph(), order = 1000, nodes = cell$id, mindist = 0, mode = "in")[[1]]
# Sort dependencies to topological order
dependencies <- names(topo_sort(ego_graph, mode = "in")[-1])
for(dependency in dependencies) {
updates <- c(updates, self$run_cell(self$cells[[dependency]], update = FALSE))
}
}
updates
},
data_frame = function() {
bind_rows(lapply(self$cells, "[", c("id", "value", "position", "hasImage"))) %>%
arrange(position)
},
getGraph = function() {
return(private$graph)
},
print = function() {
for(cell in self$cells) {
cat(cell, "\n", sep = "")
}
}
),
private = list(
env = NULL,
callstack = c(),
name_to_id = c(),
graph = graph.empty(directed = TRUE),
wrap = function(name) {
paste0(name, " %<a-% {
private$callstack <- c(private$callstack, '", name, "')
get('", name, "_saved', private$env)
}
")
}
)
)
nb <- ReactiveNotebook$new()
nb$run_cell(list(id = "start", value = "start <- 3", position = 1))
nb$run_cell(list(id = "x", value = "x <- seq(start, 10, 0.1)", position = 2))
nb$data_frame()
nb$move(0.5, 2)
ReactiveNotebook <- R6Class("ReactiveNotebook",
public = list(
cells = list(),
initialize = function() {
private$env <- new.env()
},
run_in_env = function(code) {
eval(parse(text = code), private$env)
},
move = function(source, destination) {
self$cells <- map(self$cells, function(cell) {
if(cell$position == source) cell$position <- destination
cell
})
cell_ranks <- rank(unlist(lapply(self$cells, '[', 'position')))
print(cell_ranks)
i <- 1
for(id in names(self$cells)) {
self$cells[[id]]$position <- cell_ranks[i]
i <- i + 1
}
cell_ranks
},
delete_cell = function(cell) {
if(is.null(self$cells[[cell$id]])) return()
if(!is.null(self$cells[[cell$id]]$name)) {
self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, ")"))
self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, "_saved)"))
}
position <- self$cells[[cell$id]]$position
self$cells[[cell$id]] <- NULL
self$cells <- map(self$cells, function(cell) {
if(cell$position > position) cell$position <- cell$position - 1
cell
})
if(cell$id %in% names(V(private$graph))) {
private$graph <- delete.vertices(private$graph, V(private$graph)[[cell$id]])
}
},
run_cell = function(cell, update = TRUE) {
private$callstack = c()
# Capture plots
while(dev.cur() > 1) dev.off()
ggplot2:::.store$set(NULL)
svgPath <- paste0(file.path(staticDir, cell$id), ".svg")
svg(filename = svgPath)
dev.control(displaylist = "enable")
#eval(parse(text = paste0("svg('", str_replace_all(svgPath, "\\\\", "/"), "')")), private$env)
#eval(parse(text = 'dev.control(displaylist = "enable")'), private$env)
name <- NULL
if(str_detect(cell$value, "^.+ <-")) {
name <- str_match(cell$value, "^(.+?) ?<-")[,2]
modified_cell <- str_replace(cell$value, paste0("^", name), paste0(name, "_saved"))
self$run_in_env(private$wrap(name))
res <- self$run_in_env(modified_cell)
}
else {
res <- eval(parse(text = cell$value), private$env)
}
#p <- eval(parse(text = "recordPlot()"), private$env)
p <- recordPlot()
p2 <- last_plot()
dev.off()
if(!is.null(p2)) {
ggsave(svgPath)
}
hasImage = !is.null(p[[1]]) || !is.null(p2)
pos <- cell$position
if(is.null(pos) && length(self$cells) > 0) {
positions <- sapply(self$cells, `[[`, "position")
pos <- max(positions) + 1
}
else if(is.null(pos)){
pos <- 1
}
self$cells <- map(self$cells, function(cell) {
if(cell$position >= pos) cell$position <- cell$position + 1
cell
})
self$cells[[cell$id]] = list(
id = cell$id,
value = cell$value,
position = pos,
hasImage = hasImage,
name = name,
result = res
);
if(!is.null(name)) {
private$name_to_id[name] = cell$id
}
if(!(cell$id %in% names(V(private$graph)))) {
private$graph <- add_vertices(private$graph, 1, name = cell$id)
}
for(call in private$callstack) {
call_id <- private$name_to_id[call]
if(!are.connected(private$graph, cell$id, call_id)) {
private$graph <- add_edges(private$graph, c(cell$id, call_id))
}
}
if(is.null(res)) res <- ""
updates = c(cell$id)
if(update == TRUE) {
# Get dependencies
ego_graph <- make_ego_graph(self$getGraph(), order = 1000, nodes = cell$id, mindist = 0, mode = "in")[[1]]
# Sort dependencies to topological order
dependencies <- names(topo_sort(ego_graph, mode = "in")[-1])
for(dependency in dependencies) {
updates <- c(updates, self$run_cell(self$cells[[dependency]], update = FALSE))
}
}
updates
},
data_frame = function() {
bind_rows(lapply(self$cells, "[", c("id", "value", "position", "hasImage"))) %>%
arrange(position)
},
getGraph = function() {
return(private$graph)
},
print = function() {
for(cell in self$cells) {
cat(cell, "\n", sep = "")
}
}
),
private = list(
env = NULL,
callstack = c(),
name_to_id = c(),
graph = graph.empty(directed = TRUE),
wrap = function(name) {
paste0(name, " %<a-% {
private$callstack <- c(private$callstack, '", name, "')
get('", name, "_saved', private$env)
}
")
}
)
)
nb <- ReactiveNotebook$new()
nb$run_cell(list(id = "start", value = "start <- 3", position = 1))
nb$run_cell(list(id = "x", value = "x <- seq(start, 10, 0.1)", position = 2))
nb$data_frame()
nb <- ReactiveNotebook$new()
nb$run_cell(list(id = "start", value = "start <- 3", position = 1))
nb$run_cell(list(id = "x", value = "x <- seq(start, 10, 0.1)", position = 2))
nb$data_frame()
nb$move(2, 0.5)
ReactiveNotebook <- R6Class("ReactiveNotebook",
public = list(
cells = list(),
initialize = function() {
private$env <- new.env()
},
run_in_env = function(code) {
eval(parse(text = code), private$env)
},
move = function(source, destination) {
self$cells <- map(self$cells, function(cell) {
if(cell$position == source) cell$position <- destination
cell
})
cell_ranks <- rank(unlist(lapply(self$cells, '[', 'position')))
i <- 1
for(id in names(self$cells)) {
self$cells[[id]]$position <- cell_ranks[i]
i <- i + 1
}
cell_ranks
},
delete_cell = function(cell) {
if(is.null(self$cells[[cell$id]])) return()
if(!is.null(self$cells[[cell$id]]$name)) {
self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, ")"))
self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, "_saved)"))
}
position <- self$cells[[cell$id]]$position
self$cells[[cell$id]] <- NULL
self$cells <- map(self$cells, function(cell) {
if(cell$position > position) cell$position <- cell$position - 1
cell
})
if(cell$id %in% names(V(private$graph))) {
private$graph <- delete.vertices(private$graph, V(private$graph)[[cell$id]])
}
},
run_cell = function(cell, update = TRUE) {
private$callstack = c()
# Capture plots
while(dev.cur() > 1) dev.off()
ggplot2:::.store$set(NULL)
svgPath <- paste0(file.path(staticDir, cell$id), ".svg")
svg(filename = svgPath)
dev.control(displaylist = "enable")
#eval(parse(text = paste0("svg('", str_replace_all(svgPath, "\\\\", "/"), "')")), private$env)
#eval(parse(text = 'dev.control(displaylist = "enable")'), private$env)
name <- NULL
if(str_detect(cell$value, "^.+ <-")) {
name <- str_match(cell$value, "^(.+?) ?<-")[,2]
modified_cell <- str_replace(cell$value, paste0("^", name), paste0(name, "_saved"))
self$run_in_env(private$wrap(name))
res <- self$run_in_env(modified_cell)
}
else {
res <- eval(parse(text = cell$value), private$env)
}
#p <- eval(parse(text = "recordPlot()"), private$env)
p <- recordPlot()
p2 <- last_plot()
dev.off()
if(!is.null(p2)) {
ggsave(svgPath)
}
hasImage = !is.null(p[[1]]) || !is.null(p2)
pos <- cell$position
if(is.null(pos) && length(self$cells) > 0) {
positions <- sapply(self$cells, `[[`, "position")
pos <- max(positions) + 1
}
else if(is.null(pos)){
pos <- 1
}
self$cells <- map(self$cells, function(cell) {
if(cell$position >= pos) cell$position <- cell$position + 1
cell
})
self$cells[[cell$id]] = list(
id = cell$id,
value = cell$value,
position = pos,
hasImage = hasImage,
name = name,
result = res
);
if(!is.null(name)) {
private$name_to_id[name] = cell$id
}
if(!(cell$id %in% names(V(private$graph)))) {
private$graph <- add_vertices(private$graph, 1, name = cell$id)
}
for(call in private$callstack) {
call_id <- private$name_to_id[call]
if(!are.connected(private$graph, cell$id, call_id)) {
private$graph <- add_edges(private$graph, c(cell$id, call_id))
}
}
if(is.null(res)) res <- ""
updates = c(cell$id)
if(update == TRUE) {
# Get dependencies
ego_graph <- make_ego_graph(self$getGraph(), order = 1000, nodes = cell$id, mindist = 0, mode = "in")[[1]]
# Sort dependencies to topological order
dependencies <- names(topo_sort(ego_graph, mode = "in")[-1])
for(dependency in dependencies) {
updates <- c(updates, self$run_cell(self$cells[[dependency]], update = FALSE))
}
}
updates
},
data_frame = function() {
bind_rows(lapply(self$cells, "[", c("id", "value", "position", "hasImage"))) %>%
arrange(position)
},
getGraph = function() {
return(private$graph)
},
print = function() {
for(cell in self$cells) {
cat(cell, "\n", sep = "")
}
}
),
private = list(
env = NULL,
callstack = c(),
name_to_id = c(),
graph = graph.empty(directed = TRUE),
wrap = function(name) {
paste0(name, " %<a-% {
private$callstack <- c(private$callstack, '", name, "')
get('", name, "_saved', private$env)
}
")
}
)
)
nb <- ReactiveNotebook$new()
nb$run_cell(list(id = "start", value = "start <- 3", position = 1))
nb$run_cell(list(id = "x", value = "x <- seq(start, 10, 0.1)", position = 2))
nb$data_frame()
nb$move(2, 0.5)
nb$data_frame()
notebook
notebook$data_frame()
notebook <- ReactiveNotebook$new()
stopServer(server)
server <- startServer(
host = "0.0.0.0",
port = 5000,
app = list(
onWSOpen = function(ws) {
if(length(notebook$cells) > 0) {
ws$send(toJSON(list(cells = map(notebook$cells, formatCell)[order(unlist(lapply(notebook$cells, "[", "position")), decreasing = FALSE)])))
}
else {
ws$send(toJSON(list(cells = c())))
}
ws$onMessage(function(binary, contents) {
payload = fromJSON(contents)
result <- NULL
if(payload$type == "update") {
cell <- payload$cell
changeset <- tryCatch({
notebook$run_cell(cell)
}, error = function(e) {
e
})
#if(is.null(value)) value <- ""
#result <- list(id = cell$id, result = paste0(capture.output(value), collapse = "\n"), hasImage = hasImage)
if(!("error" %in% class(changeset))) {
result <- map(changeset, function(id) formatCell(notebook$cells[[id]]))
}
else {
result <- list(id = cell$id, error = toString(changeset))
}
}
else if(payload$type == "delete") {
cell <- payload$cell
notebook$delete_cell(cell)
}
else if(payload$type == "move") {
notebook$move(payload$source, payload$destination)
}
if(!is.null(result)) {
ws$send(toJSON(result))
}
})
},
staticPaths = list(
"/static" = staticDir
)
)
)
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
read_rds("kernels.rds")
read_rds("kernels.rds")$cells
lapply(read_rds("kernels.rds")$cells, '[', "value")
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
notebook$data_frame()
lapply(read_rds("kernels.rds")$cells, '[', "value")
lapply(read_rds("kernels.rds")$cells, '[', "value")
lapply(read_rds("kernels.rds")$cells, '[', "value") %>% unlist()
lapply(read_rds("kernels.rds")$cells, '[', "value") %>% unlist() %>% unname()
lapply(read_rds("kernels.rds")$cells, '[', "value") %>% unlist() %>% unname() %>% tail()
write_rds(notebook, "kernels.rds")
