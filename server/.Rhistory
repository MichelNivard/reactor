value = cell$value,
position = pos,
hasImage = hasImage,
name = name,
result = res
);
if(!is.null(name)) {
private$name_to_id[name] = cell$id
}
if(!(cell$id %in% names(V(private$graph)))) {
private$graph <- add_vertices(private$graph, 1, name = cell$id)
}
for(call in private$callstack) {
call_id <- private$name_to_id[call]
if(!are.connected(private$graph, cell$id, call_id)) {
private$graph <- add_edges(private$graph, c(cell$id, call_id))
}
}
if(is.null(res)) res <- ""
updates = c(cell$id)
if(update == TRUE) {
updates <- c(updates, self$propogate_updates(cell))
}
updates
},
viewUpdate = function(cell, value) {
self$run_in_env(str_c(cell$name, "_saved[1] = ", value))
updates <- self$propogate_updates(cell)
updates
},
propogate_updates = function(cell) {
# Get dependencies
updates <- c()
ego_graph <- make_ego_graph(self$getGraph(), order = 1000, nodes = cell$id, mindist = 0, mode = "in")[[1]]
# Sort dependencies to topological order
dependencies <- names(topo_sort(ego_graph, mode = "in")[-1])
for(dependency in dependencies) {
updates <- c(updates, self$run_cell(self$cells[[dependency]], update = FALSE))
}
updates
},
data_frame = function() {
bind_rows(lapply(self$cells, "[", c("id", "value", "position", "hasImage"))) %>%
arrange(position)
},
getGraph = function() {
return(private$graph)
},
print = function() {
for(cell in self$cells) {
cat(cell, "\n", sep = "")
}
},
export = function() {
topo <- topo_sort(private$graph, mode = "in")
res <- lapply(self$cells[topo], `[[`, "value") %>% str_c(collapse = "\n")
res
}
),
private = list(
env = NULL,
callstack = c(),
name_to_id = c(),
graph = graph.empty(directed = TRUE),
wrap = function(name) {
paste0(name, " %<a-% {
private$callstack <- c(private$callstack, '", name, "')
get('", name, "_saved', private$env)
}
")
}
)
)
nb <- ReactiveNotebook$new()
nb$run_cell(list(id = "start", value = "start <- slider()", position = 1))
nb$run_cell(list(id = "x", value = "y <- as.numeric(start)", position = 2))
nb$export()
nb$export() %>%
cat(file = "./test.rnb")
staticDir = tempdir()
source("ReactiveNotebook.R")
options(max.print = 10)
notebook <- ReactiveNotebook$new()
formatCell <- function(cell) {
if(class(cell$result) %in% c("md", "html", "latex")) {
res <- paste0(cell$result, collapse = "\n")
}
else if(class(cell$result) == "matrix") {
res <- cell$result
}
else if(class(cell$result) == "view") {
res <- paste0(attr(cell$result, "view"), collapse = "\n")
}
else {
res <- paste0(capture.output(cell$result), collapse = "\n")
}
list(
id = cell$id,
result = res,
value = cell$value,
RClass = class(cell$result),
name = cell$name,
position = cell$position,
#hasImage = FALSE
hasImage = cell$hasImage
)
}
server <- startServer(
host = "0.0.0.0",
port = 5000,
app = list(
onWSOpen = function(ws) {
if(length(notebook$cells) > 0) {
ws$send(toJSON(list(cells = map(notebook$cells, formatCell)[order(unlist(lapply(notebook$cells, "[", "position")), decreasing = FALSE)])))
}
else {
ws$send(toJSON(list(cells = c())))
}
ws$onMessage(function(binary, contents) {
payload = fromJSON(contents)
result <- NULL
if(payload$type == "update") {
cell <- payload$cell
changeset <- tryCatch({
notebook$run_cell(cell)
}, error = function(e) {
e
})
#if(is.null(value)) value <- ""
#result <- list(id = cell$id, result = paste0(capture.output(value), collapse = "\n"), hasImage = hasImage)
if(!("error" %in% class(changeset))) {
result <- map(changeset, function(id) formatCell(notebook$cells[[id]]))
}
else {
result <- list(id = cell$id, error = toString(changeset))
}
}
else if(payload$type == "delete") {
cell <- payload$cell
notebook$delete_cell(cell)
}
else if(payload$type == "move") {
notebook$move(payload$source, payload$destination)
}
else if(payload$type == "updateView") {
print(payload)
changeset <- notebook$viewUpdate(payload$cell, payload$value)
if(!("error" %in% class(changeset))) {
result <- map(changeset, function(id) formatCell(notebook$cells[[id]]))
}
else {
result <- list(id = cell$id, error = toString(changeset))
}
}
if(!is.null(result)) {
ws$send(toJSON(result))
}
})
},
staticPaths = list(
"/static" = staticDir
)
)
)
s
stopServer(server)
server <- startServer(
host = "0.0.0.0",
port = 5000,
app = list(
onWSOpen = function(ws) {
if(length(notebook$cells) > 0) {
ws$send(toJSON(list(cells = map(notebook$cells, formatCell)[order(unlist(lapply(notebook$cells, "[", "position")), decreasing = FALSE)])))
}
else {
ws$send(toJSON(list(cells = c())))
}
ws$onMessage(function(binary, contents) {
payload = fromJSON(contents)
result <- NULL
if(payload$type == "update") {
cell <- payload$cell
changeset <- tryCatch({
notebook$run_cell(cell)
}, error = function(e) {
e
})
#if(is.null(value)) value <- ""
#result <- list(id = cell$id, result = paste0(capture.output(value), collapse = "\n"), hasImage = hasImage)
if(!("error" %in% class(changeset))) {
result <- map(changeset, function(id) formatCell(notebook$cells[[id]]))
}
else {
result <- list(id = cell$id, error = toString(changeset))
}
}
else if(payload$type == "delete") {
cell <- payload$cell
notebook$delete_cell(cell)
}
else if(payload$type == "move") {
notebook$move(payload$source, payload$destination)
}
else if(payload$type == "updateView") {
print(payload)
changeset <- notebook$viewUpdate(payload$cell, payload$value)
if(!("error" %in% class(changeset))) {
result <- map(changeset, function(id) formatCell(notebook$cells[[id]]))
}
else {
result <- list(id = cell$id, error = toString(changeset))
}
}
if(!is.null(result)) {
ws$send(toJSON(result))
}
})
},
staticPaths = list(
"/static" = staticDir
)
)
)
notebook$export()
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lng=174.768, lat=-36.852, popup="The birthplace of R")
m
install.packages("leaflet")
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lng=174.768, lat=-36.852, popup="The birthplace of R")
m
library(leaflet)
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lng=174.768, lat=-36.852, popup="The birthplace of R")
m
class(m)
print(m)
str(m)
print(m) %>% class()
grDevices::dev.list()
htmlwidgets:::print.htmlwidget()
htmlwidgets:::print.htmlwidget
htmlwidgets::print.suppress_viewer
htmlwidgets:::print.suppress_viewer
htmlwidgets:::print.htmlwidget
getOption("viewer")
options(viewer = NULL)
str(m)
htmlwidgets:::print.htmlwidget
htmltools::as.tags(m)
htmltools::as.tags(m)
options(viewer = function(url) url)
m
options(viewer = function(url, ...e) url)
options(viewer = function(url, ...) url)
m
options(viewer = function(url, ...e) print(url))
m
options(viewer = function(url, ...) print(url))
m
m
str(m)
options(viewer = function(url, ...) print(url))
htmlwidgets:::print.htmlwidget()
htmlwidgets:::print.htmlwidget
class(m)
ReactiveNotebook <- R6Class("ReactiveNotebook",
public = list(
cells = list(),
initialize = function() {
private$env <- new.env()
},
run_in_env = function(code) {
eval(parse(text = code), private$env)
},
move = function(source, destination) {
self$cells <- map(self$cells, function(cell) {
if(cell$position == source) cell$position <- destination
cell
})
cell_ranks <- rank(unlist(lapply(self$cells, '[', 'position')))
i <- 1
for(id in names(self$cells)) {
self$cells[[id]]$position <- cell_ranks[i]
i <- i + 1
}
cell_ranks
},
delete_cell = function(cell) {
if(is.null(self$cells[[cell$id]])) return()
if(!is.null(self$cells[[cell$id]]$name)) {
self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, ")"))
self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, "_saved)"))
}
position <- self$cells[[cell$id]]$position
self$cells[[cell$id]] <- NULL
self$cells <- map(self$cells, function(cell) {
if(cell$position > position) cell$position <- cell$position - 1
cell
})
if(cell$id %in% names(V(private$graph))) {
private$graph <- delete.vertices(private$graph, V(private$graph)[[cell$id]])
}
},
run_cell = function(cell, update = TRUE) {
private$callstack = c()
# Capture plots
while(dev.cur() > 1) dev.off()
ggplot2:::.store$set(NULL)
svgPath <- paste0(file.path(staticDir, cell$id), ".svg")
svg(filename = svgPath)
dev.control(displaylist = "enable")
#eval(parse(text = paste0("svg('", str_replace_all(svgPath, "\\\\", "/"), "')")), private$env)
#eval(parse(text = 'dev.control(displaylist = "enable")'), private$env)
name <- NULL
if(str_detect(cell$value, "^.+ <-")) {
name <- str_match(cell$value, "^(.+?) ?<-")[,2]
modified_cell <- str_replace(cell$value, paste0("^", name), paste0(name, "_saved"))
self$run_in_env(private$wrap(name))
res <- self$run_in_env(modified_cell)
}
else {
res <- eval(parse(text = cell$value), private$env)
}
if("htmlwidget" %in% class(res)) {
htmlPath = paste0(file.path(staticDir, cell$id), ".html")
htmlwidgets::saveWidget(res, htmlPath, selfcontained = TRUE)
}
#p <- eval(parse(text = "recordPlot()"), private$env)
p <- recordPlot()
p2 <- last_plot()
dev.off()
if(!is.null(p2)) {
ggsave(svgPath)
}
hasImage = !is.null(p[[1]]) || !is.null(p2)
pos <- cell$position
if(is.null(pos) && length(self$cells) > 0) {
positions <- sapply(self$cells, `[[`, "position")
pos <- max(positions) + 1
}
else if(is.null(pos)){
pos <- 1
}
self$cells <- map(self$cells, function(cell) {
if(cell$position >= pos) cell$position <- cell$position + 1
cell
})
self$cells[[cell$id]] = list(
id = cell$id,
value = cell$value,
position = pos,
hasImage = hasImage,
name = name,
result = res
);
if(!is.null(name)) {
private$name_to_id[name] = cell$id
}
if(!(cell$id %in% names(V(private$graph)))) {
private$graph <- add_vertices(private$graph, 1, name = cell$id)
}
for(call in private$callstack) {
call_id <- private$name_to_id[call]
if(!are.connected(private$graph, cell$id, call_id)) {
private$graph <- add_edges(private$graph, c(cell$id, call_id))
}
}
if(is.null(res)) res <- ""
updates = c(cell$id)
if(update == TRUE) {
updates <- c(updates, self$propogate_updates(cell))
}
updates
},
viewUpdate = function(cell, value) {
self$run_in_env(str_c(cell$name, "_saved[1] = ", value))
updates <- self$propogate_updates(cell)
updates
},
propogate_updates = function(cell) {
# Get dependencies
updates <- c()
ego_graph <- make_ego_graph(self$getGraph(), order = 1000, nodes = cell$id, mindist = 0, mode = "in")[[1]]
# Sort dependencies to topological order
dependencies <- names(topo_sort(ego_graph, mode = "in")[-1])
for(dependency in dependencies) {
updates <- c(updates, self$run_cell(self$cells[[dependency]], update = FALSE))
}
updates
},
data_frame = function() {
bind_rows(lapply(self$cells, "[", c("id", "value", "position", "hasImage"))) %>%
arrange(position)
},
getGraph = function() {
return(private$graph)
},
print = function() {
for(cell in self$cells) {
cat(cell, "\n", sep = "")
}
},
export = function() {
topo <- topo_sort(private$graph, mode = "in")
res <- lapply(self$cells[topo], `[[`, "value") %>% str_c(collapse = "\n")
res
}
),
private = list(
env = NULL,
callstack = c(),
name_to_id = c(),
graph = graph.empty(directed = TRUE),
wrap = function(name) {
paste0(name, " %<a-% {
private$callstack <- c(private$callstack, '", name, "')
get('", name, "_saved', private$env)
}
")
}
)
)
stopServer(server)
notebook <- ReactiveNotebook$new()
formatCell <- function(cell) {
if(class(cell$result) %in% c("md", "html", "latex")) {
res <- paste0(cell$result, collapse = "\n")
}
else if(class(cell$result) == "matrix") {
res <- cell$result
}
else if(class(cell$result) == "view") {
res <- paste0(attr(cell$result, "view"), collapse = "\n")
}
else {
res <- paste0(capture.output(cell$result), collapse = "\n")
}
list(
id = cell$id,
result = res,
value = cell$value,
RClass = class(cell$result),
name = cell$name,
position = cell$position,
#hasImage = FALSE
hasImage = cell$hasImage
)
}
server <- startServer(
host = "0.0.0.0",
port = 5000,
app = list(
onWSOpen = function(ws) {
if(length(notebook$cells) > 0) {
ws$send(toJSON(list(cells = map(notebook$cells, formatCell)[order(unlist(lapply(notebook$cells, "[", "position")), decreasing = FALSE)])))
}
else {
ws$send(toJSON(list(cells = c())))
}
ws$onMessage(function(binary, contents) {
payload = fromJSON(contents)
result <- NULL
if(payload$type == "update") {
cell <- payload$cell
changeset <- tryCatch({
notebook$run_cell(cell)
}, error = function(e) {
e
})
#if(is.null(value)) value <- ""
#result <- list(id = cell$id, result = paste0(capture.output(value), collapse = "\n"), hasImage = hasImage)
if(!("error" %in% class(changeset))) {
result <- map(changeset, function(id) formatCell(notebook$cells[[id]]))
}
else {
result <- list(id = cell$id, error = toString(changeset))
}
}
else if(payload$type == "delete") {
cell <- payload$cell
notebook$delete_cell(cell)
}
else if(payload$type == "move") {
notebook$move(payload$source, payload$destination)
}
else if(payload$type == "updateView") {
print(payload)
changeset <- notebook$viewUpdate(payload$cell, payload$value)
if(!("error" %in% class(changeset))) {
result <- map(changeset, function(id) formatCell(notebook$cells[[id]]))
}
else {
result <- list(id = cell$id, error = toString(changeset))
}
}
if(!is.null(result)) {
ws$send(toJSON(result))
}
})
},
staticPaths = list(
"/static" = staticDir
)
)
)
options(viewer = NULL)
options(viewer = function(...) NULL)
library(htmltools)
