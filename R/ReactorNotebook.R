#' Reactor Notebook R6 class
#'
#' @importFrom R6 R6Class
#' @importFrom igraph make_ego_graph topo_sort V add_edges are.connected add_vertices delete_vertices graph.empty
#' @importFrom htmlwidgets saveWidget
#' @importFrom stringr str_detect str_match str_replace str_c
#' @importFrom pryr %<a-%
#' @importFrom ggplot2 last_plot
#' @importFrom purrr map
#' @importFrom dplyr bind_rows arrange
#' 
#' @export
ReactorNotebook <- R6Class("ReactorNotebook",
  public = list(
    cells = list(),
    staticDir = "",
    initialize = function(staticDir = tempdir()) {
      private$env <- new.env()
      self$staticDir <- staticDir
    },
    
    run_in_env = function(code) {
      eval(parse(text = code), private$env)
    },
    
    #
    # source: position of cell to move
    # destination: at end of move cell will have position destination
    #
    move = function(source, destination) {
      self$cells <- map(self$cells, function(cell) {
        if(cell$position == source) cell$position <- destination
        cell
      })
      
      cell_ranks <- rank(unlist(lapply(self$cells, '[', 'position')))
      
      i <- 1
      for(id in names(self$cells)) {
        self$cells[[id]]$position <- cell_ranks[i]
        i <- i + 1
      }
      cell_ranks
    },
    delete_cell = function(cell) {
      if(is.null(self$cells[[cell$id]])) return()
      if(!is.null(self$cells[[cell$id]]$name)) {
        self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, ")"))
        self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, "_saved)"))
      }
      
      position <- self$cells[[cell$id]]$position
      
      self$cells[[cell$id]] <- NULL
      
      self$cells <- map(self$cells, function(cell) {
        if(cell$position > position) cell$position <- cell$position - 1
        cell
      })
      
      if(cell$id %in% names(V(private$graph))) {
        private$graph <- delete_vertices(private$graph, V(private$graph)[[cell$id]])
      }
    },
    run_cell = function(cell, update = TRUE) {
      private$callstack = c()
      
      #
      # Set up plot capturing
      #
      while(dev.cur() > 1) dev.off()
      
      ggplot2:::.store$set(NULL)
      
      svgPath <- paste0(file.path(self$staticDir, cell$id), ".svg")
      svg(filename = svgPath)
      dev.control(displaylist = "enable")
      
      #
      # Run the cell
      #
      name <- NULL
      if(str_detect(cell$value, "^.+ <-")) {
        name <- str_match(cell$value, "^(.+?) ?<-")[,2]
        modified_cell <- str_replace(cell$value, paste0("^", name), paste0(name, "_saved"))
        self$run_in_env(private$wrap(name))
        res <- self$run_in_env(modified_cell)
      }
      else {
        res <- eval(parse(text = cell$value), private$env)
      }
      
      #
      # Save any html widgets generated by the cell
      #
      if("htmlwidget" %in% class(res)) {
        htmlPath = paste0(file.path(self$staticDir, cell$id), ".html")
        htmlwidgets::saveWidget(res, htmlPath, selfcontained = TRUE)
      }
      
      #
      # Capture any plots from the cell
      # 
      p <- recordPlot()
      p2 <- last_plot()
      dev.off()
      if(!is.null(p2)) {
        ggsave(svgPath)
      }
      hasImage = !is.null(p[[1]]) || !is.null(p2)
      
      #
      # Figure out the cell position
      #
      pos <- cell$position
      if(is.null(pos) && length(self$cells) > 0) {
        positions <- sapply(self$cells, `[[`, "position")
        pos <- max(positions) + 1
      }
      else if(is.null(pos)){
        pos <- 1
      }
      
      self$cells <- map(self$cells, function(cell) {
        if(cell$position >= pos) cell$position <- cell$position + 1
        cell
      })
      
      # If the cell already exists but has a different name,
      # delete the previous variable.
      if(!is.null(self$cells[[cell$id]]) && !is.null(self$cells[[cell$id]]$name) && !is.null(name) && self$cells[[cell$id]]$name != name) {
        self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, ")"))
        self$run_in_env(paste0("rm(", self$cells[[cell$id]]$name, "_saved)"))
      }
      
      #
      # Save the cell
      #
      self$cells[[cell$id]] = list(
        id = cell$id,
        value = cell$value,
        position = pos,
        hasImage = hasImage,
        name = name,
        result = res,
        viewWidth = NULL,
        viewHeight = NULL,
        open = ifelse(is.null(cell$open), FALSE, cell$open)
      );
      
      
      if(!is.null(name)) {
        private$name_to_id[name] = cell$id
      }
      
      # Add the cell to the cell graph
      if(!(cell$id %in% names(V(private$graph)))) {
        private$graph <- add_vertices(private$graph, 1, name = cell$id)
      }
      
      # Add edges between the new cell and the cells it depends on
      for(call in private$callstack) {
        call_id <- private$name_to_id[call]
        if(!are.connected(private$graph, cell$id, call_id)) {
          private$graph <- add_edges(private$graph, c(cell$id, call_id))
        }
      }
      
      if(is.null(res)) res <- ""
      updates = c(cell$id)
      
      # propagate the new value of this cell to the cells that depend on it
      if(update == TRUE) {
        updates <- c(updates, self$propagate_updates(cell))
      }
      
      updates
    },
    viewUpdate = function(cell, value) {
      if(!is.null(cell$name) && cell$name != "") {
        self$run_in_env(str_c(cell$name, "_saved[1] = ", value))
      }
      
      updates <- self$propagate_updates(cell)
      updates
    },
    updateSize = function(cell, value) {
      if(!is.null(value$width)) {
        self$cells[[cell$id]]$viewWidth = c(value$width)
      }
      
      if(!is.null(value$height)) {
        self$cells[[cell$id]]$viewHeight = c(value$height)
      }
    },
    updateOpen = function(cell, value) {
      if(!is.null(value$open)) {
        self$cells[[cell$id]]$open <- value$open
      }
    },
    propagate_updates = function(cell) {
      # Get dependencies
      updates <- c()
      ego_graph <- make_ego_graph(self$getGraph(), order = 1000, nodes = cell$id, mindist = 0, mode = "in")[[1]]
      
      # Sort dependencies to topological order
      dependencies <- names(topo_sort(ego_graph, mode = "in")[-1])
      
      for(dependency in dependencies) {
        updates <- c(updates, self$run_cell(self$cells[[dependency]], update = FALSE))
      }
      updates
    },
    data_frame = function() {
      reformat_nulls <- function(x) lapply(x, function(y) ifelse(is.null(y), "", y))
      bind_rows(lapply(lapply(self$cells, "[", c("id", "value", "position", "hasImage", "viewWidth", "viewHeight")), reformat_nulls)) %>%
        arrange(position)
    },
    getGraph = function() {
      return(private$graph)
    },
    print = function() {
      for(cell in self$cells) {
        cat(cell, "\n", sep = "")
      }
    },
    export = function() {
      topo <- topo_sort(private$graph, mode = "in")
      res <- lapply(self$cells[topo], `[[`, "value") %>% str_c(collapse = "\n\n")
      
      res
    }
  ),
  private = list(
    env = NULL,
    callstack = c(),
    name_to_id = c(),
    graph = graph.empty(directed = TRUE),
    wrap = function(name) {
      paste0(name, " %<a-% {
          private$callstack <- c(private$callstack, '", name, "')
          get('", name, "_saved', private$env)
        }
      ")
    }
  )
)
